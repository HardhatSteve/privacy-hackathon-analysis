//! Report command implementation

use anyhow::{Result, bail};
use colored::*;
use std::fs;

use crate::config::Config;

/// Run the report command
pub async fn run(
    analysis_id: &str,
    format: &str,
    output_path: Option<&str>,
    config: &Config,
) -> Result<()> {
    // Check for API key
    let api_key = config.api.api_key.as_ref()
        .ok_or_else(|| anyhow::anyhow!("API key required. Run 'privacylens login' first."))?;

    println!("{} Fetching analysis {}...", "->".blue(), analysis_id);

    // Fetch analysis from API
    let client = reqwest::Client::new();
    let response = client
        .get(format!("{}/v1/analyses/{}", config.api.url, analysis_id))
        .header("X-API-Key", api_key)
        .send()
        .await?;

    if !response.status().is_success() {
        let status = response.status();
        let body = response.text().await.unwrap_or_default();
        bail!("Failed to fetch analysis ({}): {}", status, body);
    }

    let analysis: serde_json::Value = response.json().await?;

    // Generate report in requested format
    println!("{} Generating {} report...", "->".blue(), format);

    let report_content = match format.to_lowercase().as_str() {
        "json" => serde_json::to_string_pretty(&analysis)?,
        "markdown" | "md" => generate_markdown_report(&analysis),
        "sarif" => generate_sarif_report(&analysis),
        "pdf" => {
            // For PDF, we'd need a PDF generation library
            bail!("PDF generation requires additional dependencies. Use 'markdown' and convert with a tool like pandoc.");
        }
        _ => bail!("Unknown format: {}. Use: json, markdown, sarif", format),
    };

    // Output report
    if let Some(path) = output_path {
        fs::write(path, &report_content)?;
        println!("{} Report saved to: {}", "Success:".green().bold(), path);
    } else {
        println!("{}", report_content);
    }

    Ok(())
}

fn generate_markdown_report(analysis: &serde_json::Value) -> String {
    let mut md = String::new();

    md.push_str("# PrivacyLens Analysis Report\n\n");

    if let Some(score) = analysis.get("score").and_then(|s| s.get("overall")).and_then(|o| o.as_u64()) {
        md.push_str(&format!("## Privacy Score: {}/100\n\n", score));
    }

    md.push_str("## Summary\n\n");

    if let Some(vulns) = analysis.get("vulnerabilities").and_then(|v| v.as_array()) {
        let critical = vulns.iter().filter(|v| v.get("severity").and_then(|s| s.as_str()) == Some("CRITICAL")).count();
        let high = vulns.iter().filter(|v| v.get("severity").and_then(|s| s.as_str()) == Some("HIGH")).count();
        let medium = vulns.iter().filter(|v| v.get("severity").and_then(|s| s.as_str()) == Some("MEDIUM")).count();
        let low = vulns.iter().filter(|v| v.get("severity").and_then(|s| s.as_str()) == Some("LOW")).count();

        md.push_str(&format!("- Critical: {}\n", critical));
        md.push_str(&format!("- High: {}\n", high));
        md.push_str(&format!("- Medium: {}\n", medium));
        md.push_str(&format!("- Low: {}\n", low));
        md.push_str("\n");

        md.push_str("## Vulnerabilities\n\n");

        for vuln in vulns {
            if let (Some(title), Some(severity), Some(desc)) = (
                vuln.get("title").and_then(|t| t.as_str()),
                vuln.get("severity").and_then(|s| s.as_str()),
                vuln.get("description").and_then(|d| d.as_str()),
            ) {
                md.push_str(&format!("### [{}] {}\n\n", severity, title));
                md.push_str(&format!("{}\n\n", desc));

                if let Some(rec) = vuln.get("recommendation").and_then(|r| r.as_str()) {
                    md.push_str(&format!("**Recommendation:** {}\n\n", rec));
                }
            }
        }
    }

    md.push_str("\n---\n\n");
    md.push_str("*Generated by PrivacyLens*\n");

    md
}

fn generate_sarif_report(analysis: &serde_json::Value) -> String {
    // Generate SARIF 2.1.0 format
    let sarif = serde_json::json!({
        "$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
        "version": "2.1.0",
        "runs": [{
            "tool": {
                "driver": {
                    "name": "PrivacyLens",
                    "version": env!("CARGO_PKG_VERSION"),
                    "informationUri": "https://privacylens.io"
                }
            },
            "results": analysis.get("vulnerabilities")
                .and_then(|v| v.as_array())
                .map(|vulns| vulns.iter().map(|v| {
                    serde_json::json!({
                        "ruleId": v.get("id").and_then(|i| i.as_str()).unwrap_or("unknown"),
                        "level": match v.get("severity").and_then(|s| s.as_str()) {
                            Some("CRITICAL") | Some("HIGH") => "error",
                            Some("MEDIUM") => "warning",
                            _ => "note"
                        },
                        "message": {
                            "text": v.get("description").and_then(|d| d.as_str()).unwrap_or("")
                        }
                    })
                }).collect::<Vec<_>>())
                .unwrap_or_default()
        }]
    });

    serde_json::to_string_pretty(&sarif).unwrap_or_default()
}
