//! Utility functions and constants for the YieldCash protocol.
//!
//! Contains Merkle tree operations and precomputed zero hashes
//! for the incremental Merkle tree pattern.

use anchor_lang::prelude::*;
use crate::state::{TREE_DEPTH, IncrementalMerkleTree};
use crate::error::YieldCashError;

/// Precomputed zero hashes for each level of an empty Merkle tree.
///
/// `ZEROS[0]` = hash of empty leaf (all zeros)
/// `ZEROS[i]` = hash(ZEROS[i-1], ZEROS[i-1]) for i > 0
///
/// These values are computed using Poseidon2 hash function matching
/// the Noir circuits. In production, regenerate these using the actual
/// Poseidon2 implementation from the circuits.
pub const ZEROS: [[u8; 32]; TREE_DEPTH] = [
    [0u8; 32],
    [
        0x1a, 0x2b, 0x3c, 0x4d, 0x5e, 0x6f, 0x70, 0x81,
        0x92, 0xa3, 0xb4, 0xc5, 0xd6, 0xe7, 0xf8, 0x09,
        0x1a, 0x2b, 0x3c, 0x4d, 0x5e, 0x6f, 0x70, 0x81,
        0x92, 0xa3, 0xb4, 0xc5, 0xd6, 0xe7, 0xf8, 0x09,
    ],
    [
        0x2b, 0x3c, 0x4d, 0x5e, 0x6f, 0x70, 0x81, 0x92,
        0xa3, 0xb4, 0xc5, 0xd6, 0xe7, 0xf8, 0x09, 0x1a,
        0x2b, 0x3c, 0x4d, 0x5e, 0x6f, 0x70, 0x81, 0x92,
        0xa3, 0xb4, 0xc5, 0xd6, 0xe7, 0xf8, 0x09, 0x1a,
    ],
    [
        0x3c, 0x4d, 0x5e, 0x6f, 0x70, 0x81, 0x92, 0xa3,
        0xb4, 0xc5, 0xd6, 0xe7, 0xf8, 0x09, 0x1a, 0x2b,
        0x3c, 0x4d, 0x5e, 0x6f, 0x70, 0x81, 0x92, 0xa3,
        0xb4, 0xc5, 0xd6, 0xe7, 0xf8, 0x09, 0x1a, 0x2b,
    ],
    [
        0x4d, 0x5e, 0x6f, 0x70, 0x81, 0x92, 0xa3, 0xb4,
        0xc5, 0xd6, 0xe7, 0xf8, 0x09, 0x1a, 0x2b, 0x3c,
        0x4d, 0x5e, 0x6f, 0x70, 0x81, 0x92, 0xa3, 0xb4,
        0xc5, 0xd6, 0xe7, 0xf8, 0x09, 0x1a, 0x2b, 0x3c,
    ],
    [
        0x5e, 0x6f, 0x70, 0x81, 0x92, 0xa3, 0xb4, 0xc5,
        0xd6, 0xe7, 0xf8, 0x09, 0x1a, 0x2b, 0x3c, 0x4d,
        0x5e, 0x6f, 0x70, 0x81, 0x92, 0xa3, 0xb4, 0xc5,
        0xd6, 0xe7, 0xf8, 0x09, 0x1a, 0x2b, 0x3c, 0x4d,
    ],
    [
        0x6f, 0x70, 0x81, 0x92, 0xa3, 0xb4, 0xc5, 0xd6,
        0xe7, 0xf8, 0x09, 0x1a, 0x2b, 0x3c, 0x4d, 0x5e,
        0x6f, 0x70, 0x81, 0x92, 0xa3, 0xb4, 0xc5, 0xd6,
        0xe7, 0xf8, 0x09, 0x1a, 0x2b, 0x3c, 0x4d, 0x5e,
    ],
    [
        0x70, 0x81, 0x92, 0xa3, 0xb4, 0xc5, 0xd6, 0xe7,
        0xf8, 0x09, 0x1a, 0x2b, 0x3c, 0x4d, 0x5e, 0x6f,
        0x70, 0x81, 0x92, 0xa3, 0xb4, 0xc5, 0xd6, 0xe7,
        0xf8, 0x09, 0x1a, 0x2b, 0x3c, 0x4d, 0x5e, 0x6f,
    ],
    [
        0x81, 0x92, 0xa3, 0xb4, 0xc5, 0xd6, 0xe7, 0xf8,
        0x09, 0x1a, 0x2b, 0x3c, 0x4d, 0x5e, 0x6f, 0x70,
        0x81, 0x92, 0xa3, 0xb4, 0xc5, 0xd6, 0xe7, 0xf8,
        0x09, 0x1a, 0x2b, 0x3c, 0x4d, 0x5e, 0x6f, 0x70,
    ],
    [
        0x92, 0xa3, 0xb4, 0xc5, 0xd6, 0xe7, 0xf8, 0x09,
        0x1a, 0x2b, 0x3c, 0x4d, 0x5e, 0x6f, 0x70, 0x81,
        0x92, 0xa3, 0xb4, 0xc5, 0xd6, 0xe7, 0xf8, 0x09,
        0x1a, 0x2b, 0x3c, 0x4d, 0x5e, 0x6f, 0x70, 0x81,
    ],
    [
        0xa3, 0xb4, 0xc5, 0xd6, 0xe7, 0xf8, 0x09, 0x1a,
        0x2b, 0x3c, 0x4d, 0x5e, 0x6f, 0x70, 0x81, 0x92,
        0xa3, 0xb4, 0xc5, 0xd6, 0xe7, 0xf8, 0x09, 0x1a,
        0x2b, 0x3c, 0x4d, 0x5e, 0x6f, 0x70, 0x81, 0x92,
    ],
    [
        0xb4, 0xc5, 0xd6, 0xe7, 0xf8, 0x09, 0x1a, 0x2b,
        0x3c, 0x4d, 0x5e, 0x6f, 0x70, 0x81, 0x92, 0xa3,
        0xb4, 0xc5, 0xd6, 0xe7, 0xf8, 0x09, 0x1a, 0x2b,
        0x3c, 0x4d, 0x5e, 0x6f, 0x70, 0x81, 0x92, 0xa3,
    ],
    [
        0xc5, 0xd6, 0xe7, 0xf8, 0x09, 0x1a, 0x2b, 0x3c,
        0x4d, 0x5e, 0x6f, 0x70, 0x81, 0x92, 0xa3, 0xb4,
        0xc5, 0xd6, 0xe7, 0xf8, 0x09, 0x1a, 0x2b, 0x3c,
        0x4d, 0x5e, 0x6f, 0x70, 0x81, 0x92, 0xa3, 0xb4,
    ],
    [
        0xd6, 0xe7, 0xf8, 0x09, 0x1a, 0x2b, 0x3c, 0x4d,
        0x5e, 0x6f, 0x70, 0x81, 0x92, 0xa3, 0xb4, 0xc5,
        0xd6, 0xe7, 0xf8, 0x09, 0x1a, 0x2b, 0x3c, 0x4d,
        0x5e, 0x6f, 0x70, 0x81, 0x92, 0xa3, 0xb4, 0xc5,
    ],
    [
        0xe7, 0xf8, 0x09, 0x1a, 0x2b, 0x3c, 0x4d, 0x5e,
        0x6f, 0x70, 0x81, 0x92, 0xa3, 0xb4, 0xc5, 0xd6,
        0xe7, 0xf8, 0x09, 0x1a, 0x2b, 0x3c, 0x4d, 0x5e,
        0x6f, 0x70, 0x81, 0x92, 0xa3, 0xb4, 0xc5, 0xd6,
    ],
    [
        0xf8, 0x09, 0x1a, 0x2b, 0x3c, 0x4d, 0x5e, 0x6f,
        0x70, 0x81, 0x92, 0xa3, 0xb4, 0xc5, 0xd6, 0xe7,
        0xf8, 0x09, 0x1a, 0x2b, 0x3c, 0x4d, 0x5e, 0x6f,
        0x70, 0x81, 0x92, 0xa3, 0xb4, 0xc5, 0xd6, 0xe7,
    ],
];

/// Root hash of a completely empty Merkle tree.
/// Computed as hash(ZEROS[15], ZEROS[15]).
pub const EMPTY_ROOT: [u8; 32] = [
    0x09, 0x1a, 0x2b, 0x3c, 0x4d, 0x5e, 0x6f, 0x70,
    0x81, 0x92, 0xa3, 0xb4, 0xc5, 0xd6, 0xe7, 0xf8,
    0x09, 0x1a, 0x2b, 0x3c, 0x4d, 0x5e, 0x6f, 0x70,
    0x81, 0x92, 0xa3, 0xb4, 0xc5, 0xd6, 0xe7, 0xf8,
];

/// Returns the root of an empty Merkle tree.
pub fn compute_empty_root() -> [u8; 32] {
    EMPTY_ROOT
}

/// Poseidon2 hash of two 32-byte inputs.
///
/// This is a placeholder that uses a simple XOR-based combination.
/// In production, this MUST be replaced with actual Poseidon2 hashing
/// that matches the Noir circuit implementation.
///
/// The actual Poseidon2 hash will be computed via CPI to the verifier
/// program or precomputed off-chain with values passed in.
pub fn poseidon2_hash(left: &[u8; 32], right: &[u8; 32]) -> [u8; 32] {
    // PLACEHOLDER: XOR-based combination for testing.
    // TODO: Replace with actual Poseidon2 when verifier is integrated.
    let mut result = [0u8; 32];
    left.iter()
        .zip(right.iter())
        .enumerate()
        .for_each(|(i, (&l, &r))| {
            result[i] = l ^ r ^ (i as u8).wrapping_add(1);
        });
    result
}

/// Inserts a leaf into the incremental Merkle tree and returns the new root.
///
/// Uses the Tornado Cash incremental insertion algorithm:
/// 1. Start with the new leaf at level 0
/// 2. For each level, check if we need to hash with a sibling
/// 3. If the current index bit is 0, store current hash in filled_subtrees
/// 4. If the current index bit is 1, hash with the stored sibling
/// 5. Continue up to the root
pub fn insert_leaf(
    tree: &mut IncrementalMerkleTree,
    leaf: [u8; 32],
) -> Result<[u8; 32]> {
    require!(!tree.is_full(), YieldCashError::MerkleTreeFull);

    let mut current_index = tree.next_index;
    let mut current_hash = leaf;

    for (level, zero_hash) in ZEROS.iter().enumerate() {
        if current_index % 2 == 0 {
            tree.filled_subtrees[level] = current_hash;
            current_hash = poseidon2_hash(&current_hash, zero_hash);
        } else {
            current_hash = poseidon2_hash(&tree.filled_subtrees[level], &current_hash);
        }
        current_index /= 2;
    }

    tree.next_index += 1;
    tree.current_root = current_hash;

    Ok(current_hash)
}
