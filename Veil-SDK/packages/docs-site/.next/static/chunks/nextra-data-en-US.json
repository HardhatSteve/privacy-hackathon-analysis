{"/":{"title":"Introduction","data":{"":"Veil is a privacy aggregation layer for Solana.It provides a single, unified interface for sending private transactions, abstracting away the complexity of underlying privacy protocols.Developers use Veil to build privacy-preserving applications without locking themselves into a single provider or maintaining multiple disparate SDK integrations.","the-problem#The Problem":"Privacy on Solana is fragmented. To support multiple privacy solutions, you typically have to:\nManage multiple dependencies with conflicting versions.\nLearn unique SDK patterns for each protocol.\nHandle different compliance and proof generation flows.\nRewire your UI whenever a protocol updates or deprecates a feature.\nVeil solves this by treating privacy protocols as interchangeable adapters. Your application expresses an intent (\"Send 100 USDC privately\"), and Veil handles the execution via the most appropriate available adapter.","what-veil-is-not#What Veil Is Not":"Veil is not a new zero-knowledge proof system. It leverages existing, battle-tested protocols.\nVeil is not a compliance tool. While adapters may enforce compliance, Veil itself is a neutral routing layer.\nVeil is not a wallet. It integrates with existing wallet adapters to sign transactions.","when-to-use-veil#When To Use Veil":"Use Veil if:\nYou want to offer privacy features (like private payments or payroll) in your app.\nYou want to switch between privacy providers without rewriting application logic.\nYou prefer a stable, high-level API over low-level cryptographic plumbing.\nDo NOT use Veil if:\nYou are building a custom ZK protocol from scratch and need raw access to the proving circuit.\nYou need features specific to one protocol that aren't generalized (e.g., protocol-specific staking mechanisms)."}},"/getting-started":{"title":"Getting Started","data":{"":"This guide will get you sending transactions with Veil in under 5 minutes.","installation#Installation":"Install the main Veil package.\nnpm install @veil-labs/veil","setup#Setup":"Veil needs a connection to Solana and a wallet adapter to sign transactions.\nimport { createVeil } from '@veil-labs/veil';\nimport { useWallet } from '@solana/wallet-adapter-react'; // or your preferred wallet provider\n// Inside your component or hook\nconst { wallet } = useWallet();\nconst veil = createVeil({\n  wallet,\n  // Optional: Override RPC URL (defaults to public nodes)\n  rpcUrl: 'https://api.mainnet-beta.solana.com' \n});","sending-a-transaction#Sending a Transaction":"To send assets, you don't need to specify how the privacy is achieved, only what you want to do.\ntry {\n  const result = await veil.send({\n    recipient: 'BoB...', // Solana Public Key\n    amount: 100,         // Amount in natural units\n    token: 'USDC',       // Token symbol or mint address\n  });\n  console.log('Transaction confirmed:', result.signature);\n} catch (error) {\n  console.error('Transaction failed:', error);\n}","note-on-defaults#Note on Defaults":"By default, Veil includes the NoopPrivacyAdapter. This means if no specific privacy protocol is configured or available for the requested token, Veil may fall back to a standard (non-private) transfer or throw an error depending on your strictness settings. This is intentional to allow for easy development and testing on Devnet."}},"/core-concepts/mental-model":{"title":"How Veil Works","data":{"":"Veil separates intent from mechanism.In a standard Solana application, you build transactions directly. If you want privacy, you typically have to import a specific SDK, generate a proof, and construct a protocol-specific transaction.Veil changes this mental model.","the-adapter-pattern#The Adapter Pattern":"Veil operates like a universal travel adapter.\nThe Socket (Your App): You simply want to plug in and get power (send assets). You don't care about the shape of the outlet.\nThe Adapter (Privacy Protocol): This component knows how to talk to the wall (the specific on-chain program).\nVeil: The casing that holds the adapter and ensures your plug fits.\nWhen you initialize Veil, you load it with a set of Adapters. Each adapter corresponds to a specific underlying technology (like Light Protocol, Elusiv, or a simple Noop for testing).","the-flow#The Flow":"When you call veil.send(), the following happens:\nSelection: Veil looks at your request (token, amount, network).\nResolution: It asks the registered adapters: \"Can you handle this?\"\nExecution: The chosen adapter generates the necessary proofs and instructions.\nSigning: The resulting transaction is handed to your connected wallet for approval.\nThis means your frontend code looks exactly the same whether you are sending a transparent transaction on Devnet or a shielded transaction on Mainnet.","the-core-sdk#The Core SDK":"The @veil-labs/core-sdk is the brain. It manages the Registry of adapters.Most of the time, you won't interact with the Core SDK directly. You will use the high-level @veil-labs/veil package, which pre-configures the registry for you. You only need the Core SDK if you are building your own custom adapter."}},"/core-concepts/adapters":{"title":"Adapters","data":{"":"Adapters are the interchangeable engines that power Veil.","noopprivacyadapter#NoopPrivacyAdapter":"The \"No-Operation\" adapter.What it does:\nIt performs a standard, transparent SPL token transfer or SOL transfer. It offers zero privacy.Why it exists:\nLocal Development: Test your UI flows without needing a prover or a live privacy network.\nFallback: Allows your app to gracefully degrade to standard transfers if privacy services are offline (optional configuration).\nWhen to use:\nRunning tests on localhost.\nBuilding UI components before the privacy contracts are live on your target network.\nWhen NOT to use:\nProduction deployments requiring actual anonymity."}}}